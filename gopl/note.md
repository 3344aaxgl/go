# 1. new
每次调用new函数都是返回一个新的变量的地址,除非类型为空。但并不一定是在堆上创建（PS:只是一个语法糖，因为拥有GC机制，所以不需要开发人员决定变量创建的位置）

# 2. 变量的生命周期与作用域
对于在包一级声明的变量来说，他们的生命周期和整个程序的运行周期是一致的。局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不在被引用为止，然后变量的存储空间可能被回收。(PS:包一级的变量首字母大写相当于全局变量，可以在其他包中引用，而首字母小写则相当于static变量，只能在包内引用。局部变量是创建在堆还是栈上取决于是否逃逸)

```go
var global *int

//x必须在堆上创建，因为函数结束后，仍可以通过gobal访问到，称之为“逃逸”
func f() {
    var x int
    x = 1
    global = &x
}

//*y没有“逃逸”，由编译器选择创建的位置
func g() {
    y := new(int)
    *y = 1
}
```

PS:这里与C/C++有很大的不同，在《Effective C++》中，建议我们不要在函数中返回函数内声明的局部变量的指针或者引用，这是因为局部变量是分配在栈上，函数结束后就消亡了,可以直接返回局部变量对象，这里涉及到编译器的**RVO**(Return Value Optimization)。本质上还是因为golang拥有GC机制，可以由编译器决定变量的创建位置，当然也会有一些性能的损失。

# 3. 数组做参数
在将数组作为函数参数时，函数接收的时数组的副本，并没有和C/C++一样，将数组退化成指针。

```go
package main

import "fmt"

func test(arr [5]int) {
	for i := range arr[0:] {
		arr[i] += i
	}
}

func main() {
	arr := [5]int{0, 1, 2, 3, 4}
	test(arr)
	fmt.Print(arr) //[0 1 2 3 4]
}

```

# 4. slice

slice的结构类似于c++中的string，一个指向数组的指针，一个存储数据的长度，一个已分配空间的长度，也有自动扩容的功能。拷贝操作是深拷贝。

```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

# 5. Map

Map是底层为哈希表的键值对容器，其中key必须是支持==比较运算符的数据类型.迭代顺序是不确定的，并且每一次遍历的顺序都不同

# 6. 结构体

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的。拥有匿名成员可以直接访问匿名成员的属性而不用给出完整路径

# 7. 函数

Go和C一样，不支持重载。如果两个函数参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。go的函数可以有多个返回值。

# 8. 函数值

函数值类似函数指针，可以作为变量来创建，赋值，可以与nil比较，但函数值之间不可以比较，也不能当作map的key

# 9. 匿名函数

匿名函数类似lambda表达式.下面这个例子很有意思。首先类似lambda表达式，可以访问外部变量，但lambda表达式需要指明可以访问的外部变量，是传值，还是引用。函数值记录的变量的地址。然后是这个x变量没有在第一次调用函数值后被释放，变量的生命周期不由它的作用域决定。这也说明函数值不仅仅是一串代码，还记录了状态，也是函数值属于引用类型且不可比较

```go
package main

import "fmt"

func squares() func() int {
	var x int
	return func() int {
		x++
		return x * x
	}
}

func main() {
	f := squares()
	fmt.Println(f()) //1
	fmt.Println(f()) //4
	fmt.Println(f()) //9
	fmt.Println(f()) //16
}
```

函数值记录的是外部变量的地址导致的一个坑

```go
	var rmdirs []func()
	for _, d := range tempDirs() {
		dir := d               // NOTE: necessary!
		os.MkdirAll(dir, 0755) // creates parent directories too
		rmdirs = append(rmdirs, func() {
			os.RemoveAll(dir)
		})
	}
	// ...do some work…
	for _, rmdir := range rmdirs {
		rmdir() // clean up
	}
```

这里必须在for循环内对变量d进行一次拷贝，os.RemoveAll中记录的是dir的地址，而其中存储的是最后一个目录

# 10. 可变参数

类似C/C++可变参数

# 11. Deferred函数

在调用普通函数或方法前加上关键字defer，跟在defer后面的函数就会被延迟执行。多条defer语句时，执行顺序与声明顺序相反。作用有点像析构函数。《UNIX环境高级编程》中也提到过aexit函数，可以注册程序结束时调用的函数。参数记录的也是地址

# 12. Panic异常

当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer机制）

# 13. Recover捕获异常

如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异
常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运
行，但能正常返回。在未发生panic时调用recover，recover会返回nil。

# 14. 方法

在函数声明时，在其名字之前放上一个变量（接收器），即是一个方法。如果接收器本身比较大或者需要更新接收器本身时，就需要用其指针而不是对象来声明方法.包含结构体的同时，也得到了该结构体的方法，匿名类型的方法可以直接使用。作用有点像继承

# 15. 封装

Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写
字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。

# 16. 接口

**接口**类型是一种抽象类型。它不会暴露出它所代表的对象的内部值得结构和这个对象支持得基础操作的集合；只会展示出他们自己的方法。一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。通过将接口作为参数，传入实现了该接口的不同类型，可以实现多态。

**接口值**由两部分组成，一个具体的类型和那个类型的值,如果只是value为nil而type不为nil，那么该接口不是nil

**类型断言**检查它操作对象的动态类型是否和断言的类型匹配。x.(T)

* 如果T为具体类型，然后类型断言检查x的动态类型是否和T相同，如果检查成功，类型断言的结果是x的动态值，类型是T。
* 如果T为接口类型，然后类型断言检查是否x的动态类型满足T，如果这个检查成功了，返回的是一个接口类型，值为x的动态值，类型为T。

# 17. Goroutines和线程区别

* 动态栈。每一个OS线程都有一个固定大小的内存块来做栈，这个栈用来存储当前正在被调用或挂起的函数的内部变量。goroutines会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。
* goroutine调度。OS线程切换需要完整的上下文切换，Go调度器并不是用一个硬件定时器而是被Go语言"建筑"本身进行调度的，不需要进入内核进行上下文切换。
* Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的码。其默认的值是运行机器上的CPU的核心数
* Goroutine没有ID号

# 18. 不带缓存的Channels

一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作;如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。（类似pipe，但pipe只能单向）

Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导
致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发
送的数据；如果channel中已经没有数据的话将产生一个零值的数据。

# 19. 单方向的Channel

任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。但不能将一个类似 chan<- int 类型的单向型的channel转换为 chan int 类型的双向型的channel。

# 20. 带缓存的Channels

向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。

