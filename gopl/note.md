# 1. 每次调用new函数都是返回一个新的变量的地址,除非类型为空。但并不一定是在堆上创建（PS:只是一个语法糖，因为拥有GC机制，所以不需要开发人员决定变量创建的位置）

# 2. 对于在包一级声明的变量来说，他们的生命周期和整个程序的运行周期是一致的。局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不在被引用为止，然后变量的存储空间可能被回收。(PS:包一级的变量首字母大写相当于全局变量，可以在其他包中引用，而首字母小写则相当于static变量，只能在包内引用。局部变量是创建在堆还是栈上取决于是否逃逸)

```go
var global *int

//x必须在堆上创建，因为函数结束后，仍可以通过gobal访问到，称之为“逃逸”
func f() {
    var x int
    x = 1
    global = &x
}

//*y没有“逃逸”，由编译器选择创建的位置
func g() {
    y := new(int)
    *y = 1
}
```

PS:这里与C/C++有很大的不同，在《Effective C++》中，建议我们不要在函数中返回函数内声明的局部变量的指针或者引用，这是因为局部变量是分配在栈上，函数结束后就消亡了,可以直接返回局部变量对象，这里涉及到编译器的**RVO**(Return Value Optimization)。本质上还是因为golang拥有GC机制，可以由编译器决定变量的创建位置，当然也会有一些性能的损失。

# 3. 在将数组作为函数参数时，函数接收的时数组的副本，并没有和C/C++一样，将数组退化成指针。

```go
package main

import "fmt"

func test(arr [5]int) {
	for i := range arr[0:] {
		arr[i] += i
	}
}

func main() {
	arr := [5]int{0, 1, 2, 3, 4}
	test(arr)
	fmt.Print(arr) //[0 1 2 3 4]
}

```

# 4. slice

slice的结构类似于c++中的string，一个指向数组的指针，一个存储数据的长度，一个已分配空间的长度，也有自动扩容的功能。拷贝操作是深拷贝。

```go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

# 5. Map

Map是底层为哈希表的键值对容器，其中key必须是支持==比较运算符的数据类型.迭代顺序是不确定的，并且每一次遍历的顺序都不同

# 6. 结构体

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的。拥有匿名成员可以直接访问匿名成员的属性而不用给出完整路径